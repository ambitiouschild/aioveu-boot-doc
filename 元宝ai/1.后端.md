# 后端接口

1. 单个查询：直接使用数据库查询，不需要 Map
2. 批量查询：使用 Map 可以提高效率，减少数据库访问次数
3. 根据实际需求选择：不是所有场景都需要使用 Map，要根据数据量和查询模式决定

在您的保存部门场景中，由于是处理单个表单的保存操作，使用单个查询是合适的选择。如果您需要处理批量导入或多个部门同时保存，那么使用 Map 进行批量查询会更高效。

|      | 单次查询（）   | 批量查询（Map）     |
| ---- | :------------- | ------------------- |
|      |                | 1.获取分页列表      |
|      | 2.获取表单数据 |                     |
|      | 3.新增数据     |                     |
|      | 4.更新数据     |                     |
|      | 5.删除数据     |                     |
|      |                | 6.获取表单数据（Map |

## 1.视图

### 1.1实体类entity

### 1.2视图vo

#### 1.2.1分页视图vo

将被关联表的字段添加到当前表vo内

```
	/**
     * 部门名称
     */
    private String deptName;   // 新增：部门名称，用于前端列表显示
    /**
     * 岗位名称
     */
    private String positionName; // 新增：岗位名称，用于前端列表显示
    
        /**
     * 员工姓名
     */
    private String employeeName;
```



#### 1.2.2下拉框Option VO 全参构造

```
//必须使用和前端一样的字段，表单编辑时才会匹配

@Getter
@Setter
@NoArgsConstructor // 无参构造  某些框架（如 Jackson 反序列化、Hibernate）依赖无参构造函数
//添加 Lombok 注解（推荐）
@AllArgsConstructor // 添加这行注解 // 全参构造  如果添加了带参构造，编译器不再生成默认无参构造，需显式添加
@Schema( description = "会员卡号视图对象（用于下拉选择框）")
public class AioveuMemberOptionVO implements Serializable {

    @Serial
    private static final long serialVersionUID = 1L;

    //必须使用和前端一样的字段，表单编辑时才会匹配
    @Schema(description = "会员ID")
    private Long memberId;
    @Schema(description = "会员卡号")
    private String memberNo;
}
```



### 1.3查询query

### 1.4.表单form

后端表单增加id字段或者自定义字段 （新增会自动创建不需要展示id）

```

    @Schema(description = "会员等级ID")
    private Long id;
```





## 2.Controller interface 接口

### 2.1下拉框Option VO

```
    /**
     * 获取列表（用于下拉选择框）
     * @return 选项列表
     */
    @Operation(summary = "获取列表（用于下拉选择框）")
    @GetMapping("/options")
    public Result<List<DeptOptionVO>> getAllDepartmentOptions() {

        List<DeptOptionVO> departments  = aioveuDepartmentService.getAllDepartmentOptions();

        return Result.success(departments);
    }
```

### 2.2批量查询Map映射

```
    /**
     * 根据部门ID列表获取部门名称映射
     * @param deptIds 部门ID列表
     * @return 部门ID到部门名称的映射
     */
    @Operation(summary = "根据部门ID列表获取部门名称映射")
    @PostMapping("/map")
    public Result<Map<Long, String>> getDepartmentMapByIds(@RequestBody List<Long> deptIds) {
        Map<Long, String> departmentMap = aioveuDepartmentService.getDepartmentMapByIds(deptIds);
        return Result.success(departmentMap);
    }
```



## 3.Service interface 接口

### 3.1有参构造，实体类id

#### 3.1.1批量查询Map映射

    /**
     * 批量获取映射信息（新增方法）用于AioveuNameSetter  // 有参构造，实体类id
     * @param ids
     */
    Map<Long, String> getDepartmentMapByIds(List<Long> ids);

### 3.2无参，全查

#### 3.2.1批量查询Map映射

     /**
     * 批量获取映射信息（新增方法）用于AioveuNameSetter  // 无参，全查
     */
    Map<Long, String> getMemberLevelMap(); 

#### 3.2.2下拉框Option VO

```
    /**
     * 获取选项列表（用于下拉选择框）
     *
     * @return 选项列表
     */
    List<DeptOptionVO> getAllDepartmentOptions();
```

### 3.3Mapper查询

模糊查询

```
position_id LIKE CONCAT('%', #{queryParams.positionId}, '%')
```

精确查询

```
remark = #{queryParams.remark}
```





## 4.ServiceImpl 实现类



### 4.1查询分页列表

#### 4.1.1id通过映射转换为name

(表映射)将id通过映射转换为name,后端vo新加name字段用来显示

AioveuNameSetter实例使用及调用(需要映射方法)

```
        AioveuNameSetter.setNamesByMaps(
                pageVO.getRecords(),             //1.VO列表,pageVO.getRecords(),List<T> vos，应该是List<VO>列表类型而不是单个对象
                AioveuMemberAccountVO::getMemberId,           // 2.获取列表所有ID,Function<T, K> idGetter, 返回Long
                aioveuMemberService::getMemberNoMap,      // 3.批量查询列表名称信息,NameService<K> nameService,接受List<Long>，返回Map<Long, String>
                AioveuMemberAccountVO::setMemberNo             // 4设置列表名称,NameSetter<T> nameSetter, 接受VO和String
        );
```

#### 4.1.2排序实现（推荐）

只需要让最新数据显示在最前面，不需要复杂的排序选择功能

```
后端修改（关键一步）
  
 // 创建分页对象，并强制添加创建时间降序排序（最新在前）
    Page<AioveuEmployeeVO> page = new Page<>(queryParams.getPageNum(), queryParams.getPageSize());
    page.addOrder(OrderItem.desc("create_time")); // 添加这一行即可
    
    // 执行分页查询
    Page<AioveuEmployeeVO> pageVO = this.baseMapper.getAioveuEmployeePage(page, queryParams);
    
    // 添加日志验证
log.info("查询结果数量: {}, 第一条记录的创建时间: {}", 
         pageVO.getRecords().size(),
         pageVO.getRecords().get(0).getCreateTime());
```

前端不需要任何修改

您的所有表单页面都会自动将最新创建的数据显示在最前面，不需要前端做任何改动。

这会在 SQL 查询中添加 ORDER BY create_time DESC，确保最新创建的数据排在前面

**如果数据库没有 create_time 字段**

若您没有 `create_time`字段，可以使用替代方案：

```
// 使用主键降序（假设id是自增主键）
page.addOrder(OrderItem.desc("id"));

// 或使用更新时间降序
page.addOrder(OrderItem.desc("update_time"));
```

**保证性能**

在数据库中对 `create_time`字段添加索引：

```
-- MySQL
ALTER TABLE aioveu_employee ADD INDEX idx_create_time (create_time);

-- PostgreSQL
CREATE INDEX idx_employee_create_time ON aioveu_employee (create_time DESC);
```

**完全不需要前端改动的方案**

如果您希望所有查询都默认最新在前，只需这一次后端修改，前端无需任何变动。

如果您需要在前端展示排序状态，只需增加一个标识：







### 4.2获取表单数据

将Id转换为name以便前端表单输入name

```
    /**
     * 获取员工信息表单数据
     *
     * @param id 员工信息ID
     * @return 员工信息表单数据
     */
    @Override
    public AioveuEmployeeForm getAioveuEmployeeFormData(Long id) {
        // 1. 根据ID获取实体信息
        AioveuEmployee entity = this.getById(id);
        if (entity == null) {
            throw new ServiceException("不存在");
        }
        // 2. 将实体转换为表单对象
        AioveuEmployeeForm form = aioveuEmployeeConverter.toForm(entity);

        // 3. 处理映射信息（如果存在）
        if (entity.getDeptId() != null) {
                        // 使用 MyBatis-Plus 的 LambdaQueryWrapper 查询信息
                        // 创建一个 LambdaQueryWrapper 对象，用于构建查询条件
                        // 泛型 <AioveuDepartment> 指定了查询的实体类型
            LambdaQueryWrapper<AioveuDepartment> Wrapper = new LambdaQueryWrapper<>();
                        // 添加查询条件：部门ID等于指定值
                        // AioveuDepartment::getDeptId 是方法引用，表示查询 dept_id 字段
                        // entity.getDeptId() 是获取要查询的具体部门ID值
            Wrapper.eq(AioveuDepartment::getDeptId, entity.getDeptId())
                        // 指定只选择 dept_name 字段，而不是所有字段
                        // 这是一个性能优化，减少不必要的数据传输
                    .select(AioveuDepartment::getDeptName); // 只选择需要的字段

            AioveuDepartment department = aioveuDepartmentService.getOne(Wrapper);

            if (department != null) {
                form.setDeptName(department.getDeptName());
            }
        }

        if (entity.getPositionId() != null) {
                        // 使用 MyBatis-Plus 的 LambdaQueryWrapper 查询信息
                        // 创建一个 LambdaQueryWrapper 对象，用于构建查询条件
                        // 泛型 <AioveuPosition> 指定了查询的实体类型
            LambdaQueryWrapper<AioveuPosition> Wrapper = new LambdaQueryWrapper<>();
                        // 添加查询条件：岗位ID等于指定值
                        // AioveuPosition::getPositionId 是方法引用，表示查询 position_id 字段
                        // entity.getPositionId() 是获取要查询的具体岗位ID值
            Wrapper.eq(AioveuPosition::getPositionId, entity.getPositionId())
                        // 指定只选择 position_name 字段，而不是所有字段
                        // 这是一个性能优化，减少不必要的数据传输
                    .select(AioveuPosition::getPositionName); // 只选择需要的字段

            AioveuPosition position = aioveuPositionService.getOne(Wrapper);

            if (position != null) {
                form.setPositionName(position.getPositionName());
            }
        }


//        // 设置部门名称
//        if (entity.getDeptId() != null) {
//            AioveuDepartment department = aioveuDepartmentService.getById(entity.getDeptId());
//            if (department != null) {
//                form.setPositionName(department.getDeptName());
//            }
//        }
//
//        // 设置岗位名称
//        if (entity.getPositionId() != null) {
//            AioveuPosition position = aioveuPositionService.getById(entity.getPositionId());
//            if (position != null) {
//                form.setPositionName(position.getPositionName());
//            }
//        }

        return form;
    }
```



```
1.​LambdaQueryWrapper<AioveuDepartment>​
    •这是 MyBatis-Plus 提供的查询条件构建器
    •使用泛型指定要查询的实体类型（这里是 AioveuDepartment）
    •支持 Lambda 表达式，提供类型安全的查询条件构建
2.​.eq(AioveuDepartment::getDeptId, entity.getParentDeptId())​
    •eq方法表示"等于"条件
    •AioveuDepartment::getDeptId是方法引用，相当于指定数据库中的 dept_id字段
    •entity.getParentDeptId()是获取要匹配的具体值
    •整体意思是：WHERE dept_id = entity.getParentDeptId()
3.​.select(AioveuDepartment::getDeptName)​
    •select方法用于指定查询的字段
    •AioveuDepartment::getDeptName是方法引用，表示只查询 dept_name字段
    •这是一个重要的性能优化，避免了查询所有字段（SELECT *）
    •只返回需要的字段，减少网络传输和数据处理开销
```



### 4.3新增

#### 4.3.1表单字段验证器调用

##### 4.3.1.1表单字段检查是否唯一

```
        // 字段1：检查编号是否唯一（对于不依赖外键的字段，不可重复）
        NameValidator.validateEntityUnique(
                formData,
                AioveuWarehouseForm::getName,
                AioveuWarehouse::getName,
                null,
                this,
                "仓库"
        );
```

新表单字段验证器调用（新增）

```
        // 字段1：检查编号是否唯一（对于不依赖外键的字段，不可重复）
        AioveuEntityUniqueValidator.validateUniqueForCreate(
                formData,
                AioveuMemberAccountForm::getMemberId, // 获取账户号
                AioveuMemberAccount::getMemberId,    // 实体字段
                this,
                "会员账户",
                "会员卡号"
        );
```



##### 4.3.1.2表单字段检查是否存在

```
        // 字段3：检查是否存在记录（对于必须依赖外键的字段,必须存在，可重复） //在相关字段加注解  @NotNull(message = "不存在"
        EmployeeNameValidator.validateEntityExists(
                formData,
                AioveuWarehouseForm::getManagerName,  // 获取经理姓名的方法
                AioveuEmployee::getName,  // 实体字段：员工姓名
//                (form, id) -> form.setManagerId(id), // 设置经理ID的方法  // 使用显式Lambda（推荐）
                AioveuWarehouseForm::setManagerId, // 直接使用方法引用
                AioveuEmployee::getEmployeeId, // 从员工实体获取ID的方法
                aioveuEmployeeService,  // 员工服务（不是this）
                "经理"  // 实体名称（用于错误消息）
        );
```

#### 4.3.2编号生成器调用

```
    // 通过依赖注入获取NoGenerator
    @Autowired
    private NoGenerator noGenerator;
        
        
        // 1.如果单号为空，则生成
        if (StrUtil.isBlank(formData.getTypeCode())) {

            String newTypeCode = noGenerator.generateLaundryClothingTypeCode();//单号生成器方法保持一致
            formData.setTypeCode(newTypeCode);
            log.info("生成的newTypeCode: " +  newTypeCode);

        }

        // 2.无论单号是生成的还是用户提供的，都要检查是否重复。
        LambdaQueryWrapper<AioveuLaundryClothingType> wrapper = new LambdaQueryWrapper<>();
        // 正确调用：传递 formData 参数
        wrapper.eq(AioveuLaundryClothingType::getTypeCode, formData.getTypeCode());

        //3.如果重复，则重新生成（如果是用户提供的，可能需要提示用户，但根据业务逻辑，这里选择重新生成）。
        while (this.count(wrapper) > 0) {
            // 重新生成单号
            String againTypeCode = noGenerator.generateLaundryClothingTypeCode();//单号生成器方法保持一致
            formData.setTypeCode(againTypeCode);
            log.info("生成的againTypeCode: " +  againTypeCode);

            //4.重新生成后，再次检查，直到不重复为止（或者设置最大重试次数）。
            // 更新查询条件，检查新生成的单号
            wrapper.clear();
            wrapper.eq(AioveuLaundryClothingType::getTypeCode, formData.getTypeCode());
        }
```



### 4.4更新

#### 4.4.1表单字段验证器调用

```
            AioveuEntityUniqueValidator.validateUniqueForUpdate(
                    form,
                    AioveuMemberAccountForm::getMemberId,
                    AioveuMemberAccount::getMemberId,
                    AioveuMemberAccountForm::getId,
                    AioveuMemberAccount::getId,
                    aioveuMemberAccountService,
                    "会员账户",
                    "会员ID"
            );
```





### 4.5删除







### 4.6批量查询Map映射

#### 4.6.1有参构造，实体类id

```
    /**
     * 批量获取映射信息（新增方法）用于AioveuNameSetter  有参构造，实体类id
     */
    @Override
    public Map<Long, String> getMemberLevelMapByIds(List<Long> ids) {
        if (ids == null || ids.isEmpty()) {
            return Map.of();
        }

        // 1.批量查询信息
//        List<AioveuMemberLevel> memberLevels = this.listByIds(ids);

         //1.使用 LambdaQueryWrapper，编译时安全
        List<AioveuMemberLevel> memberLevels = lambdaQuery()
                .select(AioveuMemberLevel::getId, AioveuMemberLevel::getLevelName)
                .in(AioveuMemberLevel::getId, ids)
                .list();

        // 2.转换为Map: key=ID, value=名称
        return memberLevels.stream()
                .collect(Collectors.toMap(
                        AioveuMemberLevel::getId,
                        AioveuMemberLevel::getLevelName
                ));
    }
```

#### 4.6.2无参数，全查

```
    /**
     * 批量获取映射信息（新增方法）用于AioveuNameSetter  无参数
     */
    @Override
    public Map<Long, String> getMemberLevelMap() {

        // 1.批量查询信息
//        List<AioveuMemberLevel> memberLevels = this.list();

         // 1.使用 LambdaQueryWrapper，编译时安全
        List<AioveuMemberLevel> memberLevels = lambdaQuery()
                .select(AioveuMemberLevel::getId, AioveuMemberLevel::getLevelName)
                .list();

        // 2.转换为Map: key=ID, value=名称
        return memberLevels.stream()
                .collect(Collectors.toMap(
                        AioveuMemberLevel::getId,
                        AioveuMemberLevel::getLevelName
                ));
    }
```

### 4.7下拉框Option VO

#### 4.7.1全参构造

```
    /**
     * 获取选项列表（用于下拉选择框） @AllArgsConstructor // 全参构造
     *
     * @return 选项列表
     */
    @Override
    public List<DeptOptionVO> getAllDepartmentOptions() {
        
        // 查询部门
        //List<AioveuMemberLevel> memberLevels = this.list();
        
        // 1.使用 LambdaQueryWrapper，编译时安全
        List<AioveuMemberLevel> memberLevels = lambdaQuery()
                .select(AioveuMemberLevel::getId, AioveuMemberLevel::getLevelName)
                .list();

        // 2.转换为选项对象
        List<DeptOptionVO>  deptOptionVO  = departments.stream()
                .map(dept -> new DeptOptionVO(dept.getDeptId(), dept.getDeptName()))
                .collect(Collectors.toList());

        return deptOptionVO;
    }
```

#### 4.7.2无参构造使用setter方法

```
    /**
     * 获取所有会员等级列表（用于下拉选择框） // 无参构造 使用 Setter 初始化（不修改 VO 类）
     *
     * @return 会员等级选项列表
     */
    @Override
    public List<AioveuMemberLevelOptionsVO> getAllMemberLevelsOptions2() {
        return this.list().stream()
                .map(memberLevel -> {
                    AioveuMemberLevelOptionsVO vo = new AioveuMemberLevelOptionsVO();
                    vo.setId(memberLevel.getId());   //使用 Setter 初始化（不修改 VO 类）
                    vo.setLevelName(memberLevel.getLevelName());  //使用 Setter 初始化（不修改 VO 类）
                    return vo;
                })
                .collect(Collectors.toList());
    }
```

### 4.8Map映射复合键

```
// 使用 @Autowired 注入
    @Autowired
    private AioveuDepartmentMapper aioveuDepartmentMapper;


    // 在服务层直接实现，不需要在 Mapper 中添加方法
    //利用了您已经在使用的 MyBatis-Plus 框架，避免了复杂的 XML 配置和 `@MapKey`注解的问题
    @Override
    public Map<String, Long> getDepartmentIdMapByCompositeKeys(List<String> compositeKeys) {
        // 检查输入参数是否为空或空列表
        if (compositeKeys == null || compositeKeys.isEmpty()) {
            return Collections.emptyMap();
        }

        // 初始化结果Map，用于存储复合键到部门ID的映射
        Map<String, Long> resultMap = new HashMap<>();

        // 遍历所有复合键
        for (String compositeKey : compositeKeys) {
            // 使用竖线分隔符拆分复合键
            String[] parts = compositeKey.split("\\|");

            // 确保复合键至少包含两部分（部门名称和父部门ID）
            if (parts.length >= 2) {
                // 第一部分是部门名称
                String deptName = parts[0];
                // 初始化父部门ID为null
                Integer parentDeptId = null;
                // 如果复合键包含第二部分（父部门ID）
                if (parts.length > 1) {
                    try {
                        // 尝试将第二部分转换为整数作为父部门ID
                        parentDeptId = Integer.parseInt(parts[1]);
                    } catch (NumberFormatException e) {
                        // 如果转换失败，跳过当前复合键的处理
                        continue;
                    }
                }

                // 使用 MyBatis-Plus 的 Lambda 查询
                // 查询条件：部门名称等于指定值，如果父部门ID不为空则添加父部门ID条件
                AioveuDepartment department = aioveuDepartmentMapper.selectOne(
                        new QueryWrapper<AioveuDepartment>()
                                .eq("dept_name", deptName) // 部门名称相等条件
                                .eq(parentDeptId != null, "parent_dept_id", parentDeptId) // 条件性添加父部门ID条件
                );

                // 如果查询到对应的部门记录
                if (department != null) {
                    // 将复合键和部门ID添加到结果Map中
                    resultMap.put(compositeKey, department.getDeptId().longValue());
                }
            }
        }

        // 返回包含所有有效映射的结果Map
        return resultMap;
    }
```

### 4.9名称到ID的转换

```
import cn.idev.excel.util.StringUtils;


@Service
public class AioveuEmployeeServiceImpl implements AioveuEmployeeService {
    
    @Autowired
    private AioveuDepartmentService departmentService;
    
    @Autowired
    private AioveuPositionService positionService;
    
    @Override
    public IPage<AioveuEmployeeVO> getAioveuEmployeePage(AioveuEmployeeQuery queryParams) {
        // 处理部门名称映射
        if (StringUtils.isNotBlank(queryParams.getDeptName())) {
            Long deptId = departmentService.getIdByName(queryParams.getDeptName());
            queryParams.setDeptId(deptId);
        }
        
        // 处理岗位名称映射
        if (StringUtils.isNotBlank(queryParams.getPositionName())) {
            Long positionId = positionService.getIdByName(queryParams.getPositionName());
            queryParams.setPositionId(positionId);
        }
        
        // 执行分页查询
        Page<AioveuEmployeeVO> pageVO = this.baseMapper.getAioveuEmployeePage(
            new Page<>(queryParams.getPageNum(), queryParams.getPageSize()),
            queryParams
        );
        
        // 设置部门名称
        setDeptNames(pageVO.getRecords());
        
        // 设置岗位名称
        setPositionNames(pageVO.getRecords());
        
        return pageVO;
    }
}
```

